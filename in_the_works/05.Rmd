
```{r, echo = F}
knitr::opts_chunk$set(fig.retina = 2.5)
knitr::opts_chunk$set(fig.align = "center")
```

# Bayes' Rule

"Bayes' rule is merely the mathematical relation between the prior allocation of credibility and the posterior reallocation of credibility conditional on data" [@kruschkeDoingBayesianData2015, pp. 99--100].

## Bayes' rule

> Thomas Bayes (1702–1761) was a mathematician and Presbyterian minister in England. His famous theorem was published posthumously in 1763, thanks to the extensive editorial efforts of his friend, Richard Price [@bayesLIIEssaySolving1763]. The simple rule has vast ramifications for statistical inference, and therefore as long as his name is attached to the rule, we'll continue to see his name in textbooks. But Bayes himself probably was not fully aware of these ramifications, and many historians argue that it is Bayes' successor, Pierre-Simon Laplace (1749–1827), whose name should really label this type of analysis, because it was Laplace who independently rediscovered and extensively developed the methods [e.g., @daleHistoryInverseProbability2012; @mcgrayneTheoryThatWould2011]. (p. 100)

I do recommend checking out McGrayne's book It's an easy and entertaining read. For a sneak preview, why not [listen to her](https://www.youtube.com/watch?v=8oD6eBkjF9o) discuss the main themes she covered in the book?

### Derived from definitions of conditional probability.

With Equations 5.5 and 5.6, Kruschke gave us Bayes' rule in terms of $c$ and $r$. Equation 5.5 was

$$p(c|r) = \frac{p(r|c) \; p(c)}{p(r)}.$$

Since $p(r) = \sum_{c^*}p(r|c^*)p(c^*)$, we can re-express that as Equation 5.6:

$$p(c|r) = \frac{p(r|c) \; p(c)}{\sum_{c^*}p(r|c^*) \; p(c^*)},$$

where $c^*$ "in the denominator is a variable that takes on all possible values" of $c$ (p. 101).

## Applied to parameters and data

Here we get those equations re-expressed in the terms data analysts tend to think with, parameters (i.e., $\theta$) and data (i.e., $D$):

\begin{align*}
p(\theta|D) & = \frac{p(D|\theta) \; p(\theta)}{p(D)} \;\; \text{and since} \\
p(D)        & = \sum\limits_{\theta^*}p(D|\theta^*) \; p(\theta^*), \;\; \text{it's also the case that} \\
p(\theta|D) & = \frac{p(D|\theta) \; p(\theta)}{\sum\limits_{\theta^*}p(D|\theta^*) \; p(\theta^*)}.
\end{align*}

As in the previous section where we spoke in terms of $r$ and $c$, our updated $\theta^*$ notation is meant to indicate all possible values of $\theta$. For practice, it's worth repeating how Kruschke broke this down with Equation 5.7,

$$
\underbrace{p(\theta|D)}_\text{posterior} \; = \; \underbrace{p(D|\theta)}_\text{likelihood} \;\; \underbrace{p(\theta)}_\text{prior} \; / \; \underbrace{p(D)}_\text{evidence}.
$$

> The "prior," $p(\theta)$, is the credibility of the $\theta$ values without the data $D$. The "posterior," $p(\theta|D)$, is the credibility of $\theta$ values with the data $D$ taken into account. The "likelihood," $p(D|\theta)$, is the probability that the data could be generated by the model with parameter value $\theta$. The "evidence" for the model, $p(D)$, is the overall probability of the data according to the model, determined by averaging across all possible parameter values weighted by the strength of belief in those parameter values. (pp. 106--107)

And don't forget, "evidence" is short for "marginal likelihood," which is the term we'll use in some of our code, below.

## Complete examples: Estimating bias in a coin

As we begin to work with Kruschke's coin example, we should clarify that

> when [Kruschke refered] to the "bias" in a coin, [he] sometimes [referred] to its underlying probability of coming up heads. Thus, *when a coin is fair, it has a "bias" of* $\textit{0.5}$. Other times, [Kruschke used] the term "bias" in its colloquial sense of a *departure from fairness*, as in "head biased" or "tail biased." Although [Kruschke tried] to be clear about which meaning is intended, there will be times that you will have to rely on context to determine whether "bias" means the probability of heads or departure from fairness. (p. 108, *emphasis* in the original)

In this ebook, I will generally avoid Kruschke's idiosyncratic use of the term "bias." Though be warned: it may pop up from time to time.

As the the coin example at hand, here's a way to express Kruschke's initial prior distribution in a data frame and then make Figure 5.1.a.

```{r, message = F, warning = F, fig.width = 4, fig.height = 2}
library(tidyverse)

# make the data frame for the prior
d <-
  tibble(theta = seq(from = 0, to = 1, by = 0.1),
         prior = c(0:5, 4:0) * 0.04)

# save the prior plot
p1 <- d %>%
  ggplot(aes(x = theta, y = prior)) +
  geom_col(width = .025, color = "grey50", fill = "grey50") +
  scale_x_continuous(NULL, breaks = NULL) +
  labs(title = "Prior",
       y = expression(p(theta))) +
  theme(panel.grid = element_blank())

# print the plot
p1
```

If you were curious, it is indeed the case that those `prior` values sum to 1.

```{r}
d %>% 
  summarise(s = sum(prior))
```

On page 109, Kruschke defined the Bernoulli likelihood as

$$
p(y \mid \theta) = \theta^y (1 - \theta) ^{(1 - y)},
$$

where $\theta$ is the probability of one on a given trial, and $y$ is the number of one's. When applying this to coin flips, heads are encoded as one, and tails are encoded as zero. Thus, $\theta$ is the probability of heads per flip.

On page 110, we learn further that the total number of trials is often called $N$ and the number of one's among those trials is often called $z$. Thus, we can re-express that equation as

$$
p(\{y_i\} \mid \theta) = \theta^z (1 - \theta) ^{(N - z)},
$$


where $y_i$ is the $i$th trial, and $\{y_i\}$ is the set of $N$ trials. We can encode this in a custom function called `dbern()`.

```{r}
dbern <- function(x, z = NULL, n = NULL) {
  
  # x = success probability parameter ranging from 0 to 1
  # z = number of 1's
  # n = total number of Bernoulli trials
  
  return(x^z * (1 - x)^(n - z))  
  
}
```

Now we can use our custom `dbern()` function to add the likelihood based on the values of $z$ and $N$.

```{r}
z <- 1
n <- 1

d <- 
  d %>% 
  mutate(likelihood = dbern(x = theta, z = z, n = n))

print(d)
```

Now our `d` data contains information about the likelihood, we can use those results to make the middle panel of Figure 5.1.

```{r, fig.width = 4, fig.height = 2}
# save the likelihood plot
p2 <- d %>% 
  ggplot(aes(x = theta, y = likelihood)) +
  geom_col(width = .025, color = "grey50", fill = "grey50") +
  scale_x_continuous(NULL, breaks = NULL) +
  labs(title = "Likelihood",
       y = expression(p(D*'|'*theta))) +
  theme(panel.grid = element_blank())

# print the plot
p2
```

In terms of Bayes' rule from the previous section, we can denote the likelihood $p(D \mid \theta)$.

In order to compute $p(D)$ (i.e., the *evidence* or the *marginal likelihood*), we'll need to multiply our respective prior and likelihood values for each point in our theta sequence and then sum all that up. That sum will be our *marginal likelihood*. Then we can compute the posterior $p(\theta \mid D)$ by dividing the product of the prior and the likelihood by the marginal likelihood and make Figure 5.1.c.

```{r, fig.width = 4, fig.height = 2}
# compute
d <-
  d %>% 
  mutate(marginal_likelihood = sum(prior * likelihood)) %>% 
  mutate(posterior = (prior * likelihood) / marginal_likelihood)

# save the posterior plot
p3 <- d %>%
  ggplot(aes(x = theta, y = posterior)) +
  geom_col(width = .025, color = "grey50", fill = "grey50") +
  scale_x_continuous(expression(theta), breaks = seq(from = 0, to = 1, by = .2)) +
  labs(title = "Posterior",
       y = expression(p(theta*'|'*D))) +
  theme(panel.grid = element_blank())

# print the plot
p3
```

> The posterior is a compromise between the prior distribution and the likelihood function. Sometimes this is loosely stated as a compromise between the prior and the data. The compromise favors the prior to the extent that the prior distribution is sharply peaked and the data are few. The compromise favors the likelihood function (i.e., the data) to the extent that the prior distribution is flat and the data are many. (p. 112)

You may have noticed how we have saved the last three plots as objects named `p1` through `p3`. There are many ways to combine multiple ggplots, such as stacking them one atop another like they're presented in Figure 5.1. One of the earliest methods I learned was the good old [`multiplot()` function](http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/). For a long time I relied on `grid.arrange()` from the [**gridExtra** package](https://CRAN.R-project.org/package=gridExtra) [@R-gridExtra]. But it's hard to beat the elegant syntax from [Thomas Lin Pedersen](https://twitter.com/thomasp85)'s [-@R-patchwork] [**patchwork** package](https://patchwork.data-imaginist.com/).

```{r, fig.width = 4, fig.height = 5.5}
library(patchwork)

# combine the three plots and print
p1 / p2 / p3
```

You can learn more about how to use **patchwork** [here](https://patchwork.data-imaginist.com/articles/patchwork.html). We'll have many more opportunities to practice as we progress through the chapters.

### Influence of sample size on the posterior.

To make Figure 5.2, we move away from the coarse 11-point theta sequence to a denser 1,001-point sequence of $\theta$ values. Here's how one might make the primary data for the left column of Figure 5.2.

```{r}
# update the data
z <- 1
n <- 4

# make the primary data set
d <-
  tibble(theta =   seq(from = 0,     to = 1, length.out = 1001),
         prior = c(seq(from = 0,     to = 1, length.out = 501),
                   seq(from = 0.998, to = 0, length.out = 500))) %>% 
  mutate(prior      = prior / sum(prior),
         likelihood = dbern(x = theta, z = z, n = n)) %>% 
  mutate(marginal_likelihood = sum(prior * likelihood)) %>% 
  mutate(posterior = (prior * likelihood) / marginal_likelihood)

glimpse(d)
```

The original workflow in the text used the `HDIofGrid()` function to compute HDI-related information for the plot. Here we'll take a different approach and use the `in_hdi_grid()` function we introduced in [this section][Highest density interval (HDI).] from Chapter 4 in this ebook.

```{r}
# define the function
in_hdi_grid <- function(p_vec, prob = 0.95) {
  
  sorted_prob_mass <- sort(p_vec, decreasing = TRUE)
  hdi_height_idx <- min(which(cumsum(sorted_prob_mass) >= prob))
  hdi_height <- sorted_prob_mass[hdi_height_idx]
  
  return(p_vec >= hdi_height)
  
}

# apply the function to the prior and posterior vectors
d <-
  d %>% 
  mutate(prior_in_hdi = in_hdi_grid(prior),
         posterior_in_hdi = in_hdi_grid(posterior))

glimpse(d)
```

Here's the left column of Figure 5.2.

```{r, fig.width = 4, fig.height = 4.25}
# to hold the same y-axis limit for prior and posterior
y_max_pp <-
  d %>% 
  pivot_longer(cols = c(prior, posterior)) %>% 
  slice_max(value) %>% 
  pull(value)

# save the prior plot
p1 <- d %>% 
  ggplot(aes(x = theta, y = prior)) +
  geom_col(aes(fill = prior_in_hdi)) +
  geom_line(data = d %>% 
              filter(prior_in_hdi == TRUE) %>% 
              slice(c(1, n())),
            linewidth = 0.25,
            arrow = arrow(length = unit(0.1, "cm"), 
                          ends = "both", type = "closed")) +
  scale_x_continuous(NULL, breaks = NULL) +
  scale_y_continuous(expression(p(theta)), breaks = 0:2 / 1000, limits = c(0, y_max_pp)) +
  theme(legend.position = "none",
        panel.grid = element_blank())

# save the likelihood plot
p2 <- d %>% 
  ggplot(aes(x = theta, y = likelihood)) +
  geom_col(fill = "gray67") +
  scale_x_continuous(NULL, breaks = NULL) +
  scale_y_continuous(expression(p(D*'|'*theta)), breaks = 0:3 * 4 / 100) +
  theme(legend.position = "none",
        panel.grid = element_blank())

# save the posterior plot
p3 <- d %>% 
  ggplot(aes(x = theta, y = posterior)) +
  geom_col(aes(fill = posterior_in_hdi)) +
  geom_line(data = d %>% 
              filter(posterior_in_hdi == TRUE) %>% 
              slice(c(1, n())),
            linewidth = 0.25,
            arrow = arrow(length = unit(0.1, "cm"), 
                          ends = "both", type = "closed")) +
  scale_x_continuous(expression(theta), breaks = 0:5 / 5) +
  scale_y_continuous(expression(p(theta*'|'*D)), breaks = 0:2 / 1000, limits = c(0, y_max_pp)) +
  theme(legend.position = "none",
        panel.grid = element_blank())

# combine, entitle, and print
(p1 / p2 / p3) +
  plot_annotation(title = expression("Small data "*({italic(z)==1}*", "*italic(N)==4)))
```

Note how we used the `plot_annotation()` from **patchwork** to add a global title.

Also note how even though the density distributions appear approximately solid, they are actually all densely packed sequences of vertical lines via `geom_col()`. Kruschke described this as a "comb" of points in a data grid (p. 115). If you look through the code of his `BernGrid()` function which he described in his Section 5.5 Appendix, you'll see the solid-looking shapes in his Figures 5.2 and 5.2 are also made from a densely-packed comb of vertical lines. In later chapters, we'll use a different approach via functions like `geom_area()`.

As Kruschke remarked on page 112, the mode of the posterior is at $\theta = .4$.

```{r}
d %>% 
  slice_max(posterior) %>% 
  select(theta, posterior)
```

Before we make the right column for Figure 5.2, we need to update the primary data frame `d`.

```{r}
# update the data
z <- 10
n <- 40

# make the primary data set
d <-
  tibble(theta =   seq(from = 0,     to = 1, length.out = 1001),
         prior = c(seq(from = 0,     to = 1, length.out = 501),
                   seq(from = 0.998, to = 0, length.out = 500))) %>% 
  mutate(prior      = prior / sum(prior),
         likelihood = dbern(x = theta, z = z, n = n)) %>% 
  mutate(marginal_likelihood = sum(prior * likelihood)) %>% 
  mutate(posterior = (prior * likelihood) / marginal_likelihood) %>% 
  mutate(prior_in_hdi = in_hdi_grid(prior),
         posterior_in_hdi = in_hdi_grid(posterior))

glimpse(d)
```

Here's the right column of Figure 5.2.

```{r, fig.width = 4, fig.height = 4.25}
# to hold the same y-axis limit for prior and posterior
y_max_pp <-
  d %>% 
  pivot_longer(cols = c(prior, posterior)) %>% 
  slice_max(value) %>% 
  pull(value)

# save the prior plot
p1 <- d %>% 
  ggplot(aes(x = theta, y = prior)) +
  geom_col(aes(fill = prior_in_hdi)) +
  geom_line(data = d %>% 
              filter(prior_in_hdi == TRUE) %>% 
              slice(c(1, n())),
            linewidth = 0.25,
            arrow = arrow(length = unit(0.1, "cm"), 
                          ends = "both", type = "closed")) +
  scale_x_continuous(NULL, breaks = NULL) +
  scale_y_continuous(expression(p(theta)), breaks = 0:2 * 3 / 1000, limits = c(0, y_max_pp)) +
  theme(legend.position = "none",
        panel.grid = element_blank())

# save the likelihood plot
p2 <- d %>% 
  ggplot(aes(x = theta, y = likelihood)) +
  geom_col(fill = "gray67") +
  scale_x_continuous(NULL, breaks = NULL) +
  scale_y_continuous(expression(p(D*'|'*theta)), breaks = 0:1 / 1e10) +
  theme(legend.position = "none",
        panel.grid = element_blank())

# save the posterior plot
p3 <- d %>% 
  ggplot(aes(x = theta, y = posterior)) +
  geom_col(aes(fill = posterior_in_hdi)) +
  geom_line(data = d %>% 
              filter(posterior_in_hdi == TRUE) %>% 
              slice(c(1, n())),
            linewidth = 0.25,
            arrow = arrow(length = unit(0.1, "cm"), 
                          ends = "both", type = "closed")) +
  scale_x_continuous(expression(theta), breaks = 0:5 / 5) +
  scale_y_continuous(expression(p(theta*'|'*D)), breaks = 0:2 * 3 / 1000, limits = c(0, y_max_pp)) +
  theme(legend.position = "none",
        panel.grid = element_blank())

# combine, entitle, and print
(p1 / p2 / p3) +
  plot_annotation(title = expression("Bigger data "*({italic(z)==10}*", "*italic(N)==40)))
```

Now the mode of the posterior is lower at $\theta = .268$.

```{r}
d %>% 
  slice_max(posterior) %>% 
  select(theta, posterior)
```

With just an $N = 40$, the likelihood already dominated the posterior. But this is also a function of our fairly gentle prior. "In general, the more data we have, the more precise is the estimate of the parameter(s) in the model. Larger sample sizes yield greater precision or certainty of estimation" (p. 113).

### Influence of prior on the posterior.

It's not immediately obvious how Kruschke made his prior distributions for Figure 5.3. However, hidden away in his `BernGridExample.R` file he indicated that to get the distribution for the left side of Figure 5.3, you simply raise the prior from the left of Figure 5.2 to the 0.1 power.

```{r}
# update the data
z <- 1
n <- 4

d <-
  tibble(theta = seq(from = 0, to = 1, by = .001),
         prior = c(seq(from = 0, to = 1, length.out = 501),
                   seq(from = 0.998, to = 0, length.out = 500))) %>% 
  # here's the important line of code
  mutate(prior      = prior^0.1 / sum(prior^0.1),
         likelihood = dbern(x = theta, z = z, n = n)) %>% 
  mutate(marginal_likelihood = sum(prior * likelihood)) %>% 
  mutate(posterior = (prior * likelihood) / marginal_likelihood) %>% 
  mutate(prior_in_hdi = in_hdi_grid(prior),
         posterior_in_hdi = in_hdi_grid(posterior))

glimpse(d)
```

Here's the right column of Figure 5.3.

```{r, fig.width = 4, fig.height = 4.25}
# to hold the same y-axis limit for prior and posterior
y_max_pp <-
  d %>% 
  pivot_longer(cols = c(prior, posterior)) %>% 
  slice_max(value) %>% 
  pull(value)

# save the prior plot
p1 <- d %>% 
  ggplot(aes(x = theta, y = prior)) +
  geom_col(aes(fill = prior_in_hdi)) +
  geom_line(data = d %>% 
              filter(prior_in_hdi == TRUE) %>% 
              slice(c(1, n())),
            linewidth = 0.25,
            arrow = arrow(length = unit(0.1, "cm"), 
                          ends = "both", type = "closed")) +
  scale_x_continuous(NULL, breaks = NULL) +
  scale_y_continuous(expression(p(theta)), breaks = 0:2 / 1000, limits = c(0, y_max_pp)) +
  labs(subtitle = expression("Small data "*({italic(z)==1}*", "*italic(N)==4)*", weak prior")) +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        plot.title.position = "plot")

# save the likelihood plot
p2 <- d %>% 
  ggplot(aes(x = theta, y = likelihood)) +
  geom_col(fill = "gray67") +
  scale_x_continuous(NULL, breaks = NULL) +
  scale_y_continuous(expression(p(D*'|'*theta)), breaks = 0:3 * 4 / 100) +
  theme(legend.position = "none",
        panel.grid = element_blank())

# save the posterior plot
p3 <- d %>% 
  ggplot(aes(x = theta, y = posterior)) +
  geom_col(aes(fill = posterior_in_hdi)) +
  geom_line(data = d %>% 
              filter(posterior_in_hdi == TRUE) %>% 
              slice(c(1, n())),
            linewidth = 0.25,
            arrow = arrow(length = unit(0.1, "cm"), 
                          ends = "both", type = "closed")) +
  scale_x_continuous(expression(theta), breaks = 0:5 / 5) +
  scale_y_continuous(expression(p(theta*'|'*D)), breaks = 0:2 / 1000, limits = c(0, y_max_pp)) +
  theme(legend.position = "none",
        panel.grid = element_blank())

# combine, entitle, and print
(p1 / p2 / p3)
```

With a vague flat prior and a small data set, the posterior well tend to look a lot like the likelihood. With the right side of Figure 5.3, we consider a larger data set and a stronger prior. Also, note our tricky `prior` code.

```{r, fig.width = 4, fig.height = 4.25}
# update the data
z <- 10
n <- 40

# primary data set
d <-
  tibble(theta = seq(from = 0, to = 1, by = .001),
         prior = c(seq(from = 0, to = 1, length.out = 501),
                   seq(from = 0.998, to = 0, length.out = 500))) %>% 
  # here's the important line of code
  mutate(prior      = (prior^10 / sum(prior^10)),
         likelihood = dbern(x = theta, z = z, n = n)) %>% 
  mutate(marginal_likelihood = sum(prior * likelihood)) %>% 
  mutate(posterior = (prior * likelihood) / marginal_likelihood) %>% 
  mutate(prior_in_hdi = in_hdi_grid(prior),
         posterior_in_hdi = in_hdi_grid(posterior))

# to hold the same y-axis limit for prior and posterior
y_max_pp <-
  d %>% 
  pivot_longer(cols = c(prior, posterior)) %>% 
  slice_max(value) %>% 
  pull(value)

# save the prior plot
p4 <- d %>% 
  ggplot(aes(x = theta, y = prior)) +
  geom_col(aes(fill = prior_in_hdi)) +
  geom_line(data = d %>% 
              filter(prior_in_hdi == TRUE) %>% 
              slice(c(1, n())),
            linewidth = 0.25,
            arrow = arrow(length = unit(0.1, "cm"), 
                          ends = "both", type = "closed")) +
  scale_x_continuous(NULL, breaks = NULL) +
  scale_y_continuous(NULL, breaks = 0:2 * 5 / 1000, limits = c(0, y_max_pp)) +
  labs(subtitle = expression("Bigger data "*({italic(z)==10}*", "*italic(N)==40)*", stronger prior")) +
  theme(legend.position = "none",
        panel.grid = element_blank(),
        plot.title.position = "plot")

# save the likelihood plot
p5 <- d %>% 
  ggplot(aes(x = theta, y = likelihood)) +
  geom_col(fill = "gray67") +
  scale_x_continuous(NULL, breaks = NULL) +
  scale_y_continuous(NULL, breaks = 0:1 / 1e10) +
  theme(legend.position = "none",
        panel.grid = element_blank())

# save the posterior plot
p6 <- d %>% 
  ggplot(aes(x = theta, y = posterior)) +
  geom_col(aes(fill = posterior_in_hdi)) +
  geom_line(data = d %>% 
              filter(posterior_in_hdi == TRUE) %>% 
              slice(c(1, n())),
            linewidth = 0.25,
            arrow = arrow(length = unit(0.1, "cm"), 
                          ends = "both", type = "closed")) +
  scale_x_continuous(expression(theta), breaks = 0:5 / 5) +
  scale_y_continuous(NULL, breaks = 0:2 * 5 / 1000, limits = c(0, y_max_pp)) +
  theme(legend.position = "none",
        panel.grid = element_blank())

# combine, entitle, and print
(p4 / p5 / p6)
```

Here we might expand our **patchwork** skills to combine all six ggplot objects `p1` through `p6` to make the full version of Figure 5.3.

```{r, fig.width = 7.5, fig.height = 4.25}
(p1 / p2 / p3) | (p4 / p5 / p6)
```

> Bayesian inference is intuitively rational: With a strongly informed prior that uses a lot of previous data to put high credibility over a narrow range of parameter values, it takes a lot of novel contrary data to budge beliefs away from the prior. But with a weakly informed prior that spreads credibility over a wide range of parameter values, it takes relatively little data to shift the peak of the posterior distribution toward the data (although the posterior will be relatively wide and uncertain). (p. 114)

## Why Bayesian inference can be difficult

> Determining the posterior distribution directly from Bayes' rule involves computing the evidence (a.k.a. marginal likelihood) in Equations 5.8 and 5.9. In the usual case of continuous parameters, the integral in Equation 5.9 can be impossible to solve analytically. Historically, the difficulty of the integration was addressed by restricting models to relatively simple likelihood functions with corresponding formulas for prior distributions, called *conjugate* priors, that "played nice" with the likelihood function to produce a tractable integral. (p. 115, *emphasis* in the original)

However, the simple model + conjugate prior approach has its limitations. As we'll see, we often want to fit complex models without shackling ourselves with conjugate priors—which can be quite a pain to work with. Happily,

> another kind of approximation involves randomly sampling a large number of representative combinations of parameter values from the posterior distribution. In recent decades, many such algorithms have been developed, generally referred to as Markov chain Monte Carlo (MCMC) methods. What makes these methods so useful is that they can generate representative parameter-value combinations from the posterior distribution of complex models *without* computing the integral in Bayes' rule. It is the development of these MCMC methods that has allowed Bayesian statistical methods to gain practical use. (pp. 115--116, *emphasis* in the original)

## Session info {-}

```{r}
sessionInfo()
```

```{r, eval = F, echo = F}
# remove our objects
rm(d, dbern, z, n, in_hdi_grid, p1, p2, p3, y_max_pp, p4, p5, p6)
```

```{r, echo = F, message = F, warning = F, results = "hide"}
ggplot2::theme_set(ggplot2::theme_grey())
pacman::p_unload(pacman::p_loaded(), character.only = TRUE)
```

